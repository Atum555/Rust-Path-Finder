use std::collections::HashMap;

use crate::models::{Distance, Edge, EdgeId, GraphError, Location, Node, NodeId};

pub struct Graph<N, E> {
    // Node list stored as a hash map
    // Each node gets a unique autogenerated id
    nodes: HashMap<NodeId, Node<N>>,

    // Edge list stored as a hash map
    // Each edge gets a unique autogenerated id
    edges: HashMap<EdgeId, Edge<E>>,

    // IDs counter, so no repeated IDs are used
    current_node_id: NodeId,
    current_edge_id: EdgeId,
}

impl<N, E> Graph<N, E> {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            edges: HashMap::new(),
            current_node_id: NodeId(0),
            current_edge_id: EdgeId(0),
        }
    }

    pub fn nodes(&self) -> &HashMap<NodeId, Node<N>> {
        &self.nodes
    }

    pub fn add_node(&mut self, data: N) -> NodeId {
        // Update node ID
        self.current_node_id += 1;

        // Create Node and insert it
        let node = Node::new(data);
        if self.nodes.insert(self.current_node_id, node).is_some() {
            panic!("Trying to insert a node with a repeated key");
        }

        // Return inserted node ID
        self.current_node_id
    }

    pub fn add_edge(
        &mut self,
        from_id: NodeId,
        to_id: NodeId,
        data: E,
    ) -> Result<EdgeId, GraphError> {
        // Verify that the first node exists
        if !self.nodes.contains_key(&from_id) {
            return Err(GraphError::NodeNotFound(from_id));
        };

        // Verify that the second node exists
        if !self.nodes.contains_key(&to_id) {
            return Err(GraphError::NodeNotFound(to_id));
        };

        let from_node = self.nodes.get(&from_id).unwrap();
        let to_node = self.nodes.get(&to_id).unwrap();

        // Verify that this edge doesn't exist yet
        match from_node.outgoing.get(&to_id) {
            Some(edge_id) => {
                return Err(GraphError::EdgeAlreadyExists {
                    from_id,
                    to_id,
                    edge_id: *edge_id,
                });
            }
            None => {}
        }

        if to_node.outgoing.contains_key(&from_id) {
            panic!("Nodes out of sync")
        }

        // Update edge ID
        self.current_edge_id += 1;

        // Create Edge and store it in the graph
        let edge = Edge::new(from_id, to_id, data);
        if self.edges.insert(self.current_edge_id, edge).is_some() {
            panic!("Trying to insert an edge with a repeated key");
        }

        // Add the edge ID to the first node
        let from_node = self.nodes.get_mut(&from_id).unwrap();
        from_node.outgoing.insert(to_id, self.current_edge_id);

        // Add the edge ID to the second node
        let to_node = self.nodes.get_mut(&to_id).unwrap();
        to_node.incoming.insert(from_id, self.current_edge_id);

        // Return inserted edge ID
        Ok(self.current_edge_id)
    }
}

impl Graph<Location, Distance> {
    pub fn get_node_id(&self, identifier: &str) -> Option<NodeId> {
        for node in &self.nodes {
            if node.1.data().id() == identifier {
                return Some(*node.0);
            }
        }

        for node in &self.nodes {
            if node.1.data().code() == identifier {
                return Some(*node.0);
            }
        }

        None
    }
}
